/**
 * Copyright (c) 2014, Tobia De Koninck hey--at--ledfan.be
 * This file is licensed under the AGPL version 3 or later.
 * See the COPYING file.
 */
angular.module('chat', ['ngSanitize', 'bernhardposselt.enhancetext']);
angular.module('chat').config(['enhanceTextFilterProvider', '$httpProvider', function (enhanceTextFilterProvider, $httpProvider) {
	enhanceTextFilterProvider.setOptions({
		embeddedImagesHeight: '150px',
		smilies: {
			':+1:' : OC.imagePath('chat', '/emoji/+1.png'),
			':-1:' : OC.imagePath('chat', '/emoji/-1.png'),
			':alien:' : OC.imagePath('chat', '/emoji/alien.png'),
			':angry:' : OC.imagePath('chat', '/emoji/angry.png'),
			':anguished:' : OC.imagePath('chat', '/emoji/anguished.png'),
			':astonished:' : OC.imagePath('chat', '/emoji/astonished.png'),
			':blush:' : OC.imagePath('chat', '/emoji/blush.png'),
			':bowtie:' : OC.imagePath('chat', '/emoji/bowtie.png'),
			':clap:' : OC.imagePath('chat', '/emoji/clap.png'),
			':cold_sweat:' : OC.imagePath('chat', '/emoji/cold_sweat.png'),
			':confounded:' : OC.imagePath('chat', '/emoji/confounded.png'),
			':confused:' : OC.imagePath('chat', '/emoji/confused.png'),
			':cry:' : OC.imagePath('chat', '/emoji/cry.png'),

			':disappointed:' : OC.imagePath('chat', '/emoji/disappointed.png'),
			':disappointed_relieved:' : OC.imagePath('chat', '/emoji/disappointed_relieved.png'),
			':dizzy_face:' : OC.imagePath('chat', '/emoji/dizzy_face.png'),
			':expressionless:' : OC.imagePath('chat', '/emoji/expressionless.png'),
			':facepunch:' : OC.imagePath('chat', '/emoji/facepunch.png'),
			':fearful:' : OC.imagePath('chat', '/emoji/fearful.png'),
			':fist:' : OC.imagePath('chat', '/emoji/fist.png'),
			':flushed:' : OC.imagePath('chat', '/emoji/flushed.png'),
			':frowning:' : OC.imagePath('chat', '/emoji/frowning.png'),
			':grimacing:' : OC.imagePath('chat', '/emoji/grimacing.png'),
			':grin:' : OC.imagePath('chat', '/emoji/grin.png'),
			':grinning:' : OC.imagePath('chat', '/emoji/grinning.png'),
			':hand:' : OC.imagePath('chat', '/emoji/hand.png'),
			':heart_eyes:' : OC.imagePath('chat', '/emoji/heart_eyes.png'),
			':hushed:' : OC.imagePath('chat', '/emoji/hushed.png'),
			':imp:' : OC.imagePath('chat', '/emoji/imp.png'),
			':innocent:' : OC.imagePath('chat', '/emoji/innocent.png'),
			':joy:' : OC.imagePath('chat', '/emoji/joy.png'),
			':kissing:' : OC.imagePath('chat', '/emoji/kissing.png'),
			':kissing_closed_eyes:' : OC.imagePath('chat', '/emoji/kissing_closed_eyes.png'),
			':kissing_heart:' : OC.imagePath('chat', '/emoji/kissing_heart.png'),
			':kissing_smiling_eyes:' : OC.imagePath('chat', '/emoji/kissing_smiling_eyes.png'),
			':laughing:' : OC.imagePath('chat', '/emoji/laughing.png'),
			':mask:' : OC.imagePath('chat', '/emoji/mask.png'),
			':neckbeard:' : OC.imagePath('chat', '/emoji/neckbeard.png'),
			':neutral_face:' : OC.imagePath('chat', '/emoji/neutral_face.png'),
			':no_mouth:' : OC.imagePath('chat', '/emoji/no_mouth.png'),
			':ok_hand:' : OC.imagePath('chat', '/emoji/ok_hand.png'),
			':open_hands:' : OC.imagePath('chat', '/emoji/open_hands.png'),
			':open_mouth:' : OC.imagePath('chat', '/emoji/open_mouth.png'),
			':pensive:' : OC.imagePath('chat', '/emoji/pensive.png'),
			':persevere:' : OC.imagePath('chat', '/emoji/persevere.png'),
			':point_down:' : OC.imagePath('chat', '/emoji/point_down.png'),
			':point_left:' : OC.imagePath('chat', '/emoji/point_left.png'),
			':point_right:' : OC.imagePath('chat', '/emoji/point_right.png'),
			':point_up:' : OC.imagePath('chat', '/emoji/point_up.png'),
			':point_up_2:' : OC.imagePath('chat', '/emoji/point_up_2.png'),
			':pray:' : OC.imagePath('chat', '/emoji/pray.png'),
			':punch:' : OC.imagePath('chat', '/emoji/punch.png'),
			':rage:' : OC.imagePath('chat', '/emoji/rage.png'),
			':raised_hand:' : OC.imagePath('chat', '/emoji/raised_hand.png'),
			':raised_hands:' : OC.imagePath('chat', '/emoji/raised_hands.png'),
			':relaxed:' : OC.imagePath('chat', '/emoji/relaxed.png'),
			':relieved:' : OC.imagePath('chat', '/emoji/relieved.png'),
			':satisfied:' : OC.imagePath('chat', '/emoji/satisfied.png'),
			':scream:' : OC.imagePath('chat', '/emoji/scream.png'),
			':sleeping:' : OC.imagePath('chat', '/emoji/sleeping.png'),
			':sleepy:' : OC.imagePath('chat', '/emoji/sleepy.png'),
			':smile:' : OC.imagePath('chat', '/emoji/smile.png'),
			':smiley:' : OC.imagePath('chat', '/emoji/smiley.png'),
			':smiling_imp:' : OC.imagePath('chat', '/emoji/smiling_imp.png'),
			':smirk:' : OC.imagePath('chat', '/emoji/smirk.png'),
			':sob:' : OC.imagePath('chat', '/emoji/sob.png'),
			':stuck_out_tongue:' : OC.imagePath('chat', '/emoji/stuck_out_tongue.png'),
			':stuck_out_tongue_closed_eyes:' : OC.imagePath('chat', '/emoji/stuck_out_tongue_closed_eyes.png'),
			':stuck_out_tongue_winking_eye:' : OC.imagePath('chat', '/emoji/stuck_out_tongue_winking_eye.png'),
			':sunglasses:' : OC.imagePath('chat', '/emoji/sunglasses.png'),
			':sweat:' : OC.imagePath('chat', '/emoji/sweat.png'),
			':sweat_smile:' : OC.imagePath('chat', '/emoji/sweat_smile.png'),
			':thumbsdown:' : OC.imagePath('chat', '/emoji/thumbsdown.png'),
			':thumbsup:' : OC.imagePath('chat', '/emoji/thumbsup.png'),
			':tired_face:' : OC.imagePath('chat', '/emoji/tired_face.png'),
			':triumph:' : OC.imagePath('chat', '/emoji/triumph.png'),
			':unamused:' : OC.imagePath('chat', '/emoji/unamused.png'),
			':v:' : OC.imagePath('chat', '/emoji/v.png'),
			':wave:' : OC.imagePath('chat', '/emoji/wave.png'),
			':weary:' : OC.imagePath('chat', '/emoji/weary.png'),
			':wink:' : OC.imagePath('chat', '/emoji/wink.png'),
			':worried:' : OC.imagePath('chat', '/emoji/worried.png'),
			':yum:' : OC.imagePath('chat', '/emoji/yum.png'),
		}
	});
	$httpProvider.defaults.headers.common.requesttoken = oc_requesttoken;
}]);
function tran(id, vars){
	var text = 	$('#' + id).text();
	var _build = function (text, vars) {
		return text.replace(/{([^{}]*)}/g,
			function (a, b) {
				var r = vars[b];
				return typeof r === 'string' || typeof r === 'number' ? r : a;
			}
		);
	};
	return _build(text, vars);
}
angular.module('chat').factory('och', ['convs', 'contacts', 'session', 'initvar', function(convs, contacts, $session, initvar) {
	var api = {
		command: {
			attachFile : function(convId, paths, user){
				api.util.doRequest({
					"type": "command::attach_file::request",
					"data": {
						"conv_id": convId,
						"timestamp": Time.now(),
						"user": user,
						"session_id": $session.id,
						"paths" : paths
					}
				}, function(){});
			},
			removeFile : function(convId, path){
				api.util.doRequest({
					"type": "command::remove_file::request",
					"data": {
						"conv_id": convId,
						"timestamp": Time.now(),
						"user": $session.user,
						"session_id": $session.id,
						"path" : path
					}
				}, function(){});
			},
			join: function (convId, success) {
				api.util.doRequest({
					"type": "command::join::request",
					"data": {
						"conv_id": convId,
						"timestamp": Time.now(),
						"user": $session.user,
						"session_id": $session.id
					}
				}, success);
			},
			invite: function (userToInvite, convId, success) {
				api.util.doRequest({
					"type": "command::invite::request",
					"data": {
						"conv_id": convId,
						"timestamp": Time.now(),
						"user_to_invite": userToInvite,
						"user": $session.user,
						"session_id": $session.id
					}
				}, success);
			},
			sendChatMsg: function (msg, convId, success) {
				api.util.doRequest({
					"type": "command::send_chat_msg::request",
					"data": {
						"conv_id": convId,
						"chat_msg": msg,
						"user": $session.user,
						"session_id": $session.id,
						"timestamp": Time.now()
					}
				}, success);
			},
			online: function () {
				api.util.doRequest({
					"type": "command::online::request",
					"data": {
						"user": $session.user,
						"session_id": $session.id,
						"timestamp": Time.now()
					}
				}, function () {
				});
			},
			offline: function () {
				api.util.doSyncRequest({
					"type": "command::offline::request",
					"data": {
						"user": $session.user,
						"session_id": $session.id,
						"timestamp": Time.now()
					}
				}, function () {
				});
			},
			startConv: function (userToInvite, success) {
				api.util.doRequest({
					"type": "command::start_conv::request",
					"data": {
						"user": $session.user,
						"session_id": $session.id,
						"timestamp": Time.now(),
						"user_to_invite": userToInvite
					}
				}, success);
			},
			getMessages: function (convId, startpoint, success) {
				api.util.doRequest({
					"type": "data::messages::request",
					"data": {
						"user": $session.user,
						"session_id": $session.id,
						"conv_id": convId,
						"startpoint": startpoint
					}
				}, success);
			},
			getUsers: function (convId, success) {
				api.util.doRequest({
					"type": "data::get_users::request",
					"data": {
						"user": $session.user,
						"session_id": $session.id,
						"conv_id": convId
					}
				}, success);
			}
		},
		on: {
			invite: function (data) {
				// Here update the view
				var backend = Chat.app.view.getBackends('och');
				var convId = data.conv_id;
				// TODO check if data.user is a user or a contact
				if (convs.get(convId) === undefined) {
					api.command.join(data.conv_id, function (dataJoin) {
						// After we joined we should update the users array with all users in this conversation
						var users = dataJoin.data.users;
						var msgs = dataJoin.data.messages;
						convs.addConv(convId, users, backend, msgs);
					});
				}
			},
			chatMessage: function (data) {
				convs.addChatMsg(data.conv_id, data.user, data.chat_msg,
					data.timestamp, 'och');
			},
			joined: function (data) {
				//Chat.scope.$apply(function(){
				//	Chat.scope.view.replaceUsers();
				//});
					convs.replaceUsers(data.conv_id, data.users);
			},
			online: function (data) {
				contacts.markOnline(data.user.id);
			},
			offline: function (data) {
				contacts.markOffline(data.user.id);
			},
			fileAttached : function(data){
				convs.attachFile(data.conv_id, data.path, data.timestamp, data.user);
			},
			fileRemoved : function(data){
                convs.removeFile(data.conv_id, data.path, data.timestamp, data.user);
			}
		},
		util: {
			doRequest: function (request, success) {
				$.ajax({
					type: "POST",
					url: OC.generateUrl('/apps/chat/och/api'),
					data: JSON.stringify(request),
					headers: {'Content-Type': 'application/json'}
				}).always(function (data) {
					success(data);
				});
			},
			doSyncRequest: function (request, success, error) {
				$.ajax({
					type: "POST",
					url: OC.generateUrl('/apps/chat/och/api'),
					data: JSON.stringify(request),
					headers: {'Content-Type': 'application/json'},
					async: true
				});
			},
			longPoll: function () {
				api.util.getPushMessages(function (data) {
					var ids_del = [];
					for (var push_id in data.push_msgs) {
						var push_msg = data.push_msgs[push_id];
						ids_del.push(push_id);
						api.util.handlePushMessage(push_msg);
					}
					api.util.deletePushMessages(ids_del, function () {
						api.util.longPoll();
					});
				});
			},
			handlePushMessage: function (push_msg) {
				if (push_msg.type === "invite") {
					api.on.invite(push_msg.data);
				} else if (push_msg.type === "send_chat_msg") {
					api.on.chatMessage(push_msg.data);
				} else if (push_msg.type === "joined") {
					api.on.joined(push_msg.data);
				} else if (push_msg.type === "online") {
					api.on.online(push_msg.data);
				} else if (push_msg.type === "offline") {
					api.on.offline(push_msg.data);
				} else if (push_msg.type === 'file_attached'){
					api.on.fileAttached(push_msg.data);
				} else if (push_msg.type === 'file_removed'){
					api.on.fileRemoved(push_msg.data);
				}
			},
			getPushMessages: function (success) {
				api.util.doRequest({
					"type": "push::get::request",
					"data": {
						"user": $session.user,
						"session_id": $session.id
					}
				}, success);
			},
			deletePushMessages: function (ids, success) {
				api.util.doRequest({
					"type": "push::delete::request",
					"data": {
						"user": $session.user,
						"session_id": $session.id,
						ids: ids
					}
				}, function (data) {
					success();
				});
			}
		},
		INVALID_HTTP_TYPE : 0,
		COMMAND_NOT_FOUND : 1,
		PUSH_ACTION_NOT_FOUND : 2,
		DATA_ACTION_NOT_FOUND : 3,
		NO_SESSION_ID : 6,
		USER_NOT_EQUAL_TO_OC_USER : 7,
		NO_TIMESTAMP : 8,
		NO_CONV_ID : 9,
		NO_USER_TO_INVITE : 10,
		USER_EQUAL_TO_USER_TO_INVITE : 11,
		USER_TO_INVITE_NOT_OC_USER : 12,
		NO_CHAT_MSG : 13
	};
	return {
		init : function(){
			api.util.longPoll();
			setInterval(api.command.online, 6000);
			initvar.backends.och.connected = true;
		},
		quit : function(){
			api.command.offline();
		},
		sendChatMsg : function(convId, msg){
			api.command.sendChatMsg(msg, convId, function(){});
		},
		invite : function(convId, userToInvite, groupConv, callback){
			if(groupConv){
				// We are in a group conversation
				api.command.invite(userToInvite, convId, callback);
			} else {
				var users = [];
				for (var key in convs.get(convId).users) {
					users.push(convs.get(convId).users[key]);
				}
				users.push(userToInvite);
				this.newConv(users, callback);
			}
		},
		newConv : function(userToInvite, success){
			api.command.startConv(
				userToInvite,
				success
			);
		},
		attachFile : function(convId, paths, user){
			api.command.attachFile(convId, paths, user);
		},
		removeFile : function(convId, path){
			api.command.removeFile(convId, path);
		},
		configChanged : function(){
		}
	};
}]);
angular.module('chat').factory('xmpp', ['convs', 'contacts', 'initvar', function(convs, contacts, initvar) {
	$XMPP = {
		on : {
			chatMessage : function(msg, from){
				var convId = from.substring(0, from.indexOf('/'));
				convs.addChatMsg(
					convId,
					contacts.findByBackendValue('xmpp', convId),
					msg,
					Time.now(),
					'xmpp'
				);
			},
			connected : function(){

			},
			disconnected : function(){

			}
		},
		jid: initvar.backends.xmpp.config.jid,
		password: initvar.backends.xmpp.config.password,
		conn : null,
		_onMessage : function(msg){
			var to = msg.getAttribute('to');
			var from = msg.getAttribute('from');
			var type = msg.getAttribute('type');
			var elems = msg.getElementsByTagName('body');

			if (type == "chat" && elems.length > 0) {
				var body = elems[0];
				$XMPP.on.chatMessage(Strophe.getText(body), from);
			}
			return true;
		},
		_onConnect : function(status){
			if (status == Strophe.Status.CONNECTING) {
				log('Strophe is connecting.');
			} else if (status == Strophe.Status.CONNFAIL) {
				log('Strophe failed to connect.');
				initvar.backends.xmpp.connected = false;
			} else if (status == Strophe.Status.DISCONNECTING) {
				log('Strophe is disconnecting.');
				initvar.backends.xmpp.connected = false;
			} else if (status == Strophe.Status.DISCONNECTED) {
				log('Strophe is disconnected.');
				initvar.backends.xmpp.connected = false;
			} else if (status == Strophe.Status.CONNECTED) {
				log('Strophe is connected.');
				log('ECHOBOT: Send a message to ' + $XMPP.con.jid +
				' to talk to me.');
				initvar.backends.xmpp.connected = true;
				$XMPP.con.addHandler($XMPP._onMessage, null, 'message', null, null, null);
				$XMPP.con.send($pres().tree());
			} else if (status == Strophe.Status.AUTHFAIL){
				// TODO
				alert('auth fail');
			}
		}
	};

	var log = function(msg){
		console.log(msg);
	}
	Strophe.log = function (level, msg) {
		console.log(msg);
	};

	return {
		BOSH_SERVICE : '/http-bind/',
		init : function(){
			//$XMPP.
			//Create connection
			$XMPP.con = new Strophe.Connection(this.BOSH_SERVICE);
			$XMPP.con.connect($XMPP.jid, $XMPP.password, $XMPP._onConnect);
		},
		quit : function(){
		},
		sendChatMsg : function(convId, msg){
			var reply = $msg({to: convId, from: $XMPP.jid , type: 'chat'}).c('body', null,msg
			);
			$XMPP.con.send(reply.tree());
		},
		invite : function(convId, userToInvite, groupConv, callback){
		},
		newConv : function(userToInvite, success){
		},
		attachFile : function(convId, paths, user){
		},
		removeFile : function(convId, path){
		},
		configChanged : function(){
			$XMPP.jid = initvar.backends.xmpp.config.jid;
			$XMPP.password = initvar.backends.xmpp.config.password;
			if($XMPP.con !== null) {
				$XMPP.con.disconnect();
			}
			this.init();
		}
	};
}]);

/**
 * Copyright (c) 2014, Tobia De Koninck hey--at--ledfan.be
 * This file is licensed under the AGPL version 3 or later.
 * See the COPYING file.
 */
window.Chat =  window.Chat || {};
Chat.app = Chat.app || {};
Chat.app.util = {
	timeStampToDate : function(timestamp){
		var date = new Date(timestamp * 1000);
		var hours = date.getHours();
		var minutes = (date.getMinutes() < 10 ? '0' : '') + date.getMinutes();
		var seconds = date.getSeconds();
		return	{hours : date.getHours(), minutes : (date.getMinutes() < 10 ? '0' : '') + date.getMinutes(), seconds : date.getSeconds()};
	},
	isYoutubeUrl : function(url) {
		if(url.indexOf('https://youtube.com') > -1
			|| url.indexOf('https://youtube.com') > -1
			|| url.indexOf('https://www.youtube.com') > -1
			|| url.indexOf('http://www.youtube.com') > -1
			|| url.indexOf('http://youtu.be') > -1
			){
			return true;
		} else {
			return false;
		}
	},
	isImageUrl : function(url){
		var imgRegex = /((?:https?):\/\/\S*\.(?:gif|jpg|jpeg|tiff|png|svg|webp))/gi;
		return imgRegex.test(url);
	},
	emojis : [
		{ "name" : ':+1:' , "url" : OC.imagePath('chat', 'emoji/+1.png') },
		{ "name" : ':-1:' , "url" : OC.imagePath('chat', 'emoji/-1.png') },
		{ "name" : ':alien:' , "url" : OC.imagePath('chat', 'emoji/alien.png') },
		{ "name" : ':angry:' , "url" : OC.imagePath('chat', 'emoji/angry.png') },
		{ "name" : ':anguished:' , "url" : OC.imagePath('chat', 'emoji/anguished.png') },
		{ "name" : ':astonished:' , "url" : OC.imagePath('chat', 'emoji/astonished.png') },
		{ "name" : ':blush:' , "url" : OC.imagePath('chat', 'emoji/blush.png') },
		{ "name" : ':bowtie:' , "url" : OC.imagePath('chat', 'emoji/bowtie.png') },
		{ "name" : ':clap:' , "url" : OC.imagePath('chat', 'emoji/clap.png') },
		{ "name" : ':cold_sweat:' , "url" : OC.imagePath('chat', 'emoji/cold_sweat.png') },
		{ "name" : ':confounded:' , "url" : OC.imagePath('chat', 'emoji/confounded.png') },
		{ "name" : ':confused:' , "url" : OC.imagePath('chat', 'emoji/confused.png') },
		{ "name" : ':cry:' , "url" : OC.imagePath('chat', 'emoji/cry.png') },
		{ "name" : ':disappointed:' , "url" : OC.imagePath('chat', 'emoji/disappointed.png') },
		{ "name" : ':disappointed_relieved:' , "url" : OC.imagePath('chat', 'emoji/disappointed_relieved.png') },
		{ "name" : ':dizzy_face:' , "url" : OC.imagePath('chat', 'emoji/dizzy_face.png') },
		{ "name" : ':expressionless:' , "url" : OC.imagePath('chat', 'emoji/expressionless.png') },
		{ "name" : ':facepunch:' , "url" : OC.imagePath('chat', 'emoji/facepunch.png') },
		{ "name" : ':fearful:' , "url" : OC.imagePath('chat', 'emoji/fearful.png') },
		{ "name" : ':fist:' , "url" : OC.imagePath('chat', 'emoji/fist.png') },
		{ "name" : ':flushed:' , "url" : OC.imagePath('chat', 'emoji/flushed.png') },
		{ "name" : ':frowning:' , "url" : OC.imagePath('chat', 'emoji/frowning.png') },
		{ "name" : ':grimacing:' , "url" : OC.imagePath('chat', 'emoji/grimacing.png') },
		{ "name" : ':grin:' , "url" : OC.imagePath('chat', 'emoji/grin.png') },
		{ "name" : ':grinning:' , "url" : OC.imagePath('chat', 'emoji/grinning.png') },
		{ "name" : ':hand:' , "url" : OC.imagePath('chat', 'emoji/hand.png') },
		{ "name" : ':heart_eyes:' , "url" : OC.imagePath('chat', 'emoji/heart_eyes.png') },
		{ "name" : ':hushed:' , "url" : OC.imagePath('chat', 'emoji/hushed.png') },
		{ "name" : ':imp:' , "url" : OC.imagePath('chat', 'emoji/imp.png') },
		{ "name" : ':innocent:' , "url" : OC.imagePath('chat', 'emoji/innocent.png') },
		{ "name" : ':joy:' , "url" : OC.imagePath('chat', 'emoji/joy.png') },
		{ "name" : ':kissing:' , "url" : OC.imagePath('chat', 'emoji/kissing.png') },
		{ "name" : ':kissing_closed_eyes:' , "url" : OC.imagePath('chat', 'emoji/kissing_closed_eyes.png') },
		{ "name" : ':kissing_heart:' , "url" : OC.imagePath('chat', 'emoji/kissing_heart.png') },
		{ "name" : ':kissing_smiling_eyes:' , "url" : OC.imagePath('chat', 'emoji/kissing_smiling_eyes.png') },
		{ "name" : ':laughing:' , "url" : OC.imagePath('chat', 'emoji/laughing.png') },
		{ "name" : ':mask:' , "url" : OC.imagePath('chat', 'emoji/mask.png') },
		{ "name" : ':neckbeard:' , "url" : OC.imagePath('chat', 'emoji/neckbeard.png') },
		{ "name" : ':neutral_face:' , "url" : OC.imagePath('chat', 'emoji/neutral_face.png') },
		{ "name" : ':no_mouth:' , "url" : OC.imagePath('chat', 'emoji/no_mouth.png') },
		{ "name" : ':ok_hand:' , "url" : OC.imagePath('chat', 'emoji/ok_hand.png') },
		{ "name" : ':open_hands:' , "url" : OC.imagePath('chat', 'emoji/open_hands.png') },
		{ "name" : ':open_mouth:' , "url" : OC.imagePath('chat', 'emoji/open_mouth.png') },
		{ "name" : ':pensive:' , "url" : OC.imagePath('chat', 'emoji/pensive.png') },
		{ "name" : ':persevere:' , "url" : OC.imagePath('chat', 'emoji/persevere.png') },
		{ "name" : ':point_down:' , "url" : OC.imagePath('chat', 'emoji/point_down.png') },
		{ "name" : ':point_left:' , "url" : OC.imagePath('chat', 'emoji/point_left.png') },
		{ "name" : ':point_right:' , "url" : OC.imagePath('chat', 'emoji/point_right.png') },
		{ "name" : ':point_up:' , "url" : OC.imagePath('chat', 'emoji/point_up.png') },
		{ "name" : ':point_up_2:' , "url" : OC.imagePath('chat', 'emoji/point_up_2.png') },
		{ "name" : ':pray:' , "url" : OC.imagePath('chat', 'emoji/pray.png') },
		{ "name" : ':punch:' , "url" : OC.imagePath('chat', 'emoji/punch.png') },
		{ "name" : ':rage:' , "url" : OC.imagePath('chat', 'emoji/rage.png') },
		{ "name" : ':raised_hand:' , "url" : OC.imagePath('chat', 'emoji/raised_hand.png') },
		{ "name" : ':raised_hands:' , "url" : OC.imagePath('chat', 'emoji/raised_hands.png') },
		{ "name" : ':relaxed:' , "url" : OC.imagePath('chat', 'emoji/relaxed.png') },
		{ "name" : ':relieved:' , "url" : OC.imagePath('chat', 'emoji/relieved.png') },
		{ "name" : ':satisfied:' , "url" : OC.imagePath('chat', 'emoji/satisfied.png') },
		{ "name" : ':scream:' , "url" : OC.imagePath('chat', 'emoji/scream.png') },
		{ "name" : ':sleeping:' , "url" : OC.imagePath('chat', 'emoji/sleeping.png') },
		{ "name" : ':sleepy:' , "url" : OC.imagePath('chat', 'emoji/sleepy.png') },
		{ "name" : ':smile:' , "url" : OC.imagePath('chat', 'emoji/smile.png') },
		{ "name" : ':smiley:' , "url" : OC.imagePath('chat', 'emoji/smiley.png') },
		{ "name" : ':smiling_imp:' , "url" : OC.imagePath('chat', 'emoji/smiling_imp.png') },
		{ "name" : ':smirk:' , "url" : OC.imagePath('chat', 'emoji/smirk.png') },
		{ "name" : ':sob:' , "url" : OC.imagePath('chat', 'emoji/sob.png') },
		{ "name" : ':stuck_out_tongue:' , "url" : OC.imagePath('chat', 'emoji/stuck_out_tongue.png') },
		{ "name" : ':stuck_out_tongue_closed_eyes:' , "url" : OC.imagePath('chat', 'emoji/stuck_out_tongue_closed_eyes.png') },
		{ "name" : ':stuck_out_tongue_winking_eye:' , "url" : OC.imagePath('chat', 'emoji/stuck_out_tongue_winking_eye.png') },
		{ "name" : ':sunglasses:' , "url" : OC.imagePath('chat', 'emoji/sunglasses.png') },
		{ "name" : ':sweat:' , "url" : OC.imagePath('chat', 'emoji/sweat.png') },
		{ "name" : ':sweat_smile:' , "url" : OC.imagePath('chat', 'emoji/sweat_smile.png') },
		{ "name" : ':thumbsdown:' , "url" : OC.imagePath('chat', 'emoji/thumbsdown.png') },
		{ "name" : ':thumbsup:' , "url" : OC.imagePath('chat', 'emoji/thumbsup.png') },
		{ "name" : ':tired_face:' , "url" : OC.imagePath('chat', 'emoji/tired_face.png') },
		{ "name" : ':triumph:' , "url" : OC.imagePath('chat', 'emoji/triumph.png') },
		{ "name" : ':unamused:' , "url" : OC.imagePath('chat', 'emoji/unamused.png') },
		{ "name" : ':v:' , "url" : OC.imagePath('chat', 'emoji/v.png') },
		{ "name" : ':wave:' , "url" : OC.imagePath('chat', 'emoji/wave.png') },
		{ "name" : ':weary:' , "url" : OC.imagePath('chat', 'emoji/weary.png') },
		{ "name" : ':wink:' , "url" : OC.imagePath('chat', 'emoji/wink.png') },
		{ "name" : ':worried:' , "url" : OC.imagePath('chat', 'emoji/worried.png') },
		{ "name" : ':yum:' , "url" : OC.imagePath('chat', 'emoji/yum.png') },
	]
};

/**
 * Copyright (c) 2014, Tobia De Koninck hey--at--ledfan.be
 * This file is licensed under the AGPL version 3 or later.
 * See the COPYING file.
 */
angular.module('chat').controller(
	'ConvController',
	[
		'$scope',
		'$http',
		'$filter',
		'$interval',
		'initvar',
		'convs',
		'contacts',
		'backends',
		'title',
		'session',
		function(
			$scope,
			$http,
			$filter,
			$interval,
			initvar,
			convs,
			contacts,
			backends,
			title,
			$session
		){

			$(window).unload(function(){
				$scope.quit();
			});

			Chat.scope = $scope;

			/**
			 * Object used to interact with the view
			 * @var {object} view
			 */
			$scope.view = {
				/**
				 * Stores whether an element should be visible
				 * @var {object} elements
				 */
				elements : {
					"chat" : false,
					"initDone" : false,
					"settings" : false,
					"emojiContainer" : false,
					"invite" : false,
					"files" : false
				},
				/**
				 * Called when an invite button is clicked
				 */
				inviteClick : function(){
					$scope.view.toggle('invite');
					// Focus search field
					setTimeout(function(){
						$('#invite-search-field').focus();
					}, 1);
				},
				/**
				 * Called when the popover button is clicked
				 */
				showEmojiPopover : function(){
					var height = $("#chat-window-footer").height();
					$scope.view.toggle('emojiContainer');
					setTimeout(function(){
						$('#emoji-container').css('bottom', height + 20);
					},1);
				},
				/**
				 * TODO translations
				 */
				showFilePicker : function(){
					OCdialogs.filepicker('Please choose a file to attach to the conversation', function(paths){
						for(var key in paths){
							var path = paths[key];
							convs.attachFile($session.conv, path, Time.now(), $session.user);
						}
						var backend = $scope.convs[$session.conv].backend.id;
						backends[backend].handle.attachFile($session.conv, paths, $session.user);
					}, true);
				},
				showFiles : function(){
					$scope.view.toggle('files');

				},
				/**
				 * This will flag the element as visible in the view.elements array
				 * @param {string} element the element which should be made visible (should be in the $scope.view.elements array )
				 * @param {object} $event
				 * @param {string} exception this function call will be ignored when this element is clicked
				 */
				show : function(element, $event, exception){
					if($event !== undefined){
						var classList = $event.target.classList;
						if(classList.contains(exception)){
							// the clicked item containted the exception class
							// this mean probably that we clicked on the item in side the viewed div
							// thus the div don't need to be hided;
							return;
						}
					}
					$scope.view.elements[element] = true;
				},
				/**
				 * This will flag the element as invisible in the view.elements array
				 * @param {string} element the element which should be made invisible (should be in the $scope.view.elements array )
				 * @param {object} $event
				 * @param {string} exceptions this function call will be ignored when this element is clicked
				 */
				hide : function(element, $event, exceptions){
					if($event !== undefined){
						var classList = $event.target.classList;
						for(var i = 0; i < exceptions.length; i++){
							if(classList.contains(exceptions[i])){
								// the clicked item contains the exception class
								// this mean probably that we clicked on the item in side the viewed div
								// thus the div don't need to be hided;
								return;
							}
						}
					}
					$scope.view.elements[element] = false;
				},
				/**
				 * This will toggle the visibility of the element in the view.elements array
				 * @param {string} element the element which should be made invisible (should be in the $scope.view.elements array )
				 */
				toggle : function(element){
					$scope.view.elements[element] = !$scope.view.elements[element];
				},

				/**
				 * This function will make an conv active
				 * @param {string} convId
				 * @param {object} $event
				 * @param {string} exception - when this is provided the function call will be ignored when it was this param which was clicked
				 */
				makeActive : function(convId, $event, exception){
					$scope.view.hide('emptyMsg');
					$scope.view.show('chat', $event, exception);
					$session.conv = convId;
					$scope.view.focusMsgInput();
					convs.get(convId).new_msg = false;
					$("#chat-msg-input-field").autosize({
						callback : function(){
							var height = $("#chat-msg-input-field").height();
							height = height + 15;
							$('#chat-window-footer').height(height);
							$('#chat-window-body').css('bottom', height);
							$('#chat-window-msgs').scrollTop($('#chat-window-msgs')[0].scrollHeight);
							var height = $("#chat-window-footer").height();
							$('#emoji-container').css('bottom', height + 20);
						}
					});
				},
				/**
				 * This will unActive all conversations
				 */
				unActive : function(){
					$session.conv = null;
				},
				/**
				 * This will focus the chat input field
				 */
				focusMsgInput : function(){
					$('#chat-msg-input-field');
				},
				unShare : function(convId, path, timestamp, user, key){
					var backend = $scope.convs[convId].backend.id;
					backends[backend].handle.removeFile(convId, path);
					convs.removeFile(convId, path, timestamp, user, key);
				},
                downloadFile : function(path){
                    var dir = '/';
                    var files = path;
                    OC.redirect(OC.generateUrl('/apps/files/ajax/download.php?dir={dir}&files={files}', {dir: dir, files:files}));
                }
			};

			/**
			 * This function is called when the user tries to send a chat msg
			 * This will call the sendChatMsg function on the correct backend
			 * This will add the chatMsg to the conv
			 * This will empty the chat field
			 * This will make the order of the contacts in the conv the highest
			 */
			$scope.sendChatMsg = function(){
				if ($scope.fields.chatMsg !== '' && $scope.fields.chatMsg !== null){
					var backend = convs.get($session.conv).backend.id;
					convs.addChatMsg($session.conv, $session.user, $scope.fields.chatMsg, Time.now(), backend);
					backends[backend].handle.sendChatMsg($session.conv, $scope.fields.chatMsg);
					$scope.fields.chatMsg = '';
					setTimeout(function(){
						$('#chat-msg-input-field').trigger('autosize.resize');
					},1);
					$('#chat-msg-input-field').focus();

					for (var key in convs.get($session.conv).users) {
						var user =  convs.get($session.conv).users[key];
						if(user.id !== $session.user.id){
							var order = contacts.getHighestOrder();
							contacts.contacts[user.id].order = order;
						}
					}
				}
			};

			/**
			 * @var {object} convs
			 */
			$scope.convs =  convs.convs; // DON NOT USE THIS! ONLY FOR ATTACHING TO THE SCOPE

			$scope.contacts = contacts.contacts  // DON NOT USE THIS! ONLY FOR ATTACHING TO THE SCOPE
			$scope.backends = backends;

			/**
			 * @var {object} initConvs
			 */
			$scope.initConvs = {};

			$scope.isWindowActive = true;

			$scope.fields = {
				'chatMsg' : '',
			};

			$session.user = contacts.contacts[OC.currentUser]
			$session.id = initvar.sessionId;
			$scope.initConvs = initvar.initConvs;
			$scope.initvar = initvar;

			function init() {
				for (var key in backends){
					backends[key].handle.init();
				}


				$scope.initDone = true;
				//Now join and add all the existing convs
				for (var backendId in $scope.initConvs) {
					for (var key in $scope.initConvs[backendId]){
						var conv = $scope.initConvs[backendId][key];
						var contactsInConv = [];
						for (var key in conv.users) {
							var user = conv.users[key];
							contactsInConv.push(contacts.contacts[user]);
						}
						convs.addConv(conv.id, contactsInConv, backends[backendId], [], conv.files);
						for (var key in conv.messages) {
							var msg = conv.messages[key];
							convs.addChatMsg(conv.id, contacts.contacts[msg.user], msg.msg, msg.timestamp, backends[backendId], true);
						}
						for (var key in conv.files){
							var file = conv.files[key];
							convs.addChatMsg(conv.id, file.user, tran('translations-attached', {displayname: file.user.displayname, path: file.path}),
								file.timestamp, backendId);
						}
					}
				}
				$scope.makeFirstConvActive();
				$scope.$session = $session;
			}

			/**
			 * Function called when the app is quit
			 */
			$scope.quit = function(){
				for(var id in backends){
					backends[id].handle.quit();
				}
			};

			/**
			 * This function will make the first conversation in the conversation list active
			 */
			$scope.makeFirstConvActive = function(){
				firstConv = convs.getFirstConv();
				if(firstConv === undefined){
					$session.conv = null;
					$scope.view.hide('chat');
					$scope.view.show('emptyMsg');
				} else {
					$scope.view.makeActive(firstConv);
				}
			};

			/**
			 * This function will invite the userToInvite for the $scope.$session.conv
			 * This will make the order of the conv the highest
			 * @param {object} userToInvite
			 */
			$scope.invite = function(userToInvite){
				var backend = $scope.convs[$session.conv].backend.id;
				var groupConv = $scope.convs[$session.conv].users.length > 2;
				backends[backend].handle.invite($session.conv, userToInvite, groupConv, function(response){
					if(groupConv) {
						$scope.view.replaceUsers($session.conv, response.data.users);
					} else {
						convs.addConv(response.data.conv_id, response.data.users, $scope.convs[$session.conv].backend, response.data.messages, []);
					}
				});
				$scope.view.hide('invite');
				$scope.view.makeActive($session.conv);

				var order = contacts.getHighestOrder();
				contacts.contacts[userToInvite.id].order = order;

			};

			/**
			 * This interval will make the title of the page $scope.title.title every second
			 */
			$interval(function(){
				if (title.getTitle() === '') {
					$('title').text(title.getDefaultTitle());
				} else {
					if($scope.isWindowActive === false) {
						$('title').text(title.getTitle());
					}
				}
			}, 1000);
			/**
			 * This interval will make the title of the page $scope.title.default every two second
			 */
			$interval(function(){
				$('title').text(title.getDefaultTitle());
			}, 2000);


			window.onfocus = function () {
				title.updateTitle('');
				title.emptyNewMsgs();
				$scope.isWindowActive= true;
			};

			window.onblur = function () {
				$scope.isWindowActive = false;
			};

			/**
			 * This function will add the emoji to the current position of the cursor in the chat msg input field
			 * it will place a space before and after the emoji
			 * @param name
			 */
			$scope.addEmoji = function(name){
				var element = $("#chat-msg-input-field");
				element.focus(); //ie
				var selection = element.getSelection();
				var textBefore = $scope.fields.chatMsg.substr(0, selection.start);
				var textAfter = $scope.fields.chatMsg.substr(selection.end);
				$scope.fields.chatMsg = textBefore + ' ' + name + ' ' + textAfter + ' ';
				$scope.view.hide('emojiContainer');
			};

			$scope.emojis = Chat.app.util.emojis;

			/**
			 * When there are new messages in the active conversation the chat window must be scroll to the bottom
			 */
			$scope.$watch('convs[active.conv].msgs', function(){
				setTimeout(function(){
					$('#chat-window-msgs').scrollTop($('#chat-window-msgs')[0].scrollHeight);
				},250);
			}, true);

			init();
		}
	]
);


/**
 * Copyright (c) 2014, Tobia De Koninck hey--at--ledfan.be
 * This file is licensed under the AGPL version 3 or later.
 * See the COPYING file.
 */
angular.module('chat').controller(
	'SettingsController',
	[
		'$scope',
		'$interval',
		'backends',
		'session',
		'$http',
		function(
			$scope,
			initvar,
			backends,
			$session,
			$http
		){

			Chat.settings = $scope;

			$scope.backends = backends;


			$scope.status = null;

			$scope.save = function(){
				$scope.status = 'saving';
				$http.post(OC.generateUrl('/apps/chat/config/set'), {backends: $scope.backends}).
					success(function(data, status, headers, config) {
						$scope.status = 'saved';
						// the backend configuration has changed
						// inform the backend
						for (var key in backends){
							var backend = backends[key];
							backend.handle.configChanged();
						}
					}).
					error(function(data, status, headers, config) {
						$scope.status = 'error';
					});
			};
		}
	]
);


angular.module('chat').directive('autoHeight', [function () {
	return {
		restrict: 'A',
		link: function ($scope, element, attrs) {
			if(attrs.convId === $scope.$session.conv){
				attrs.itemCount++;
			} else {
				element.css('height', attrs.minHeight + 'px');
			}
			var height = attrs.itemCount * attrs.itemHeight;
			if(height < attrs.minHeight){
				element.css('height', attrs.minHeight + 'px');
			} else {
				element.css('height', height + 'px');
			}
			//TODO
			$scope.$watch('$session.conv', function(){
				if(attrs.convId === $scope.$session.conv){
					var height = attrs.itemCount * attrs.itemHeight;
					if(attrs.itemCount > 1){
						height = height + 30;
					}
					if(height < attrs.minHeight){
						element.css('height', attrs.minHeight + 'px');
					} else {
						element.css('height', height + 'px');
					}
				} else {
					element.css('height', attrs.minHeight + 'px');
				}
			});
		}
	};
}]);
angular.module('chat').directive('avatar', ['contacts', function(contacts) {
	return {
		restrict: 'A',
		link: function ($scope, element, attrs) {
			element.applyContactAvatar(attrs.addressbookBackend, attrs.addressbookId, attrs.id, attrs.displayname, attrs.size);
			if(attrs.online !== undefined){
				element.online(attrs.isonline);
				$scope.$watch('contacts', function(){
					element.online(contacts.contacts[attrs.id].online);
				}, true);
			}
		}
	};
}]);
angular.module('chat').directive('displayname', function () {
	return {
		restrict: 'A',
		link: function ($scope, element, attrs) {
			var text  = '';
			if(typeof attrs.users === 'string' ){
				users = JSON.parse(attrs.users);
			} else {
				users = attrs.users;
			}
			for (var key in users){
				var user = users[key];
				if(user.id !== OC.currentUser){
					text += user.displayname + ' ';
				}
			}
			element.text(text);
		}
	};
});
angular.module('chat').directive('inviteMobile', function () {
	return {
		restrict: 'A',
		link: function ($scope, element, attrs) {
			if($(window).width() < 768){
				// we are
				// this means the navigation is hidden
				// we have to position the invite popover below the "add person" button
				element.addClass('invite-container-mobile');
			}
		}
	};
});
angular.module('chat').directive('ngEnter', function () {
	return function (scope, element, attrs) {
		element.bind("keydown keypress", function (event) {
			if(event.which === 13) {
				if (event.shiftKey === false){
					scope.$apply(function (){
						scope.$eval(attrs.ngEnter);
					});
					event.preventDefault();
				}
			}
		});
	};
});
angular.module('chat').directive('time', function () {
	return {
		restrict: 'A',
		link: function ($scope, element, attrs) {
			var time = moment.unix(parseInt(attrs.timestamp)).format('h:mm');
			element.text(time);
		}
	};
});
angular.module('chat').directive('tipsy', function () {
	return {
		restrict: 'A',
		link: function ($scope, element, attrs) {
			element.tipsy();
		}
	};
});
angular.module('chat').factory('backends', ['initvar', '$injector', function(initvar, $injector) {
	var backends = initvar.backends;
	var result = {};
	for (var id in backends){
		result[id] = backends[id];
		result[id].handle = $injector.get(id);
	}
	return result;
}]);
angular.module('chat').factory('contacts', ['$filter', 'initvar', function($filter, initvar) {
	return {
		contacts : initvar.contactsObj,
		getHighestOrder : function(){
			var sortedContacts = $filter('orderObjectBy')(this.contacts, 'order');
			return sortedContacts[sortedContacts.length - 1].order + 1;
		},

		/**
		 * This will flag a contact in the $scope.contactsObj as online
		 * @param {string} userId
		 */
		markOnline : function(id){
			this.contacts[id].online = true;
		},
		/**
		* This will flag a contact in the $scope.contactsObj as offline
		* @param {string} userId
		*/
		markOffline : function(id){
			this.contacts[id].online = false;
		},
		findByBackendValue : function(backendId, value){
			for (var key in this.contacts){
				var contact = this.contacts[key];
				for (var backendKey in contact.backends){
					var backend = contact.backends[backendKey];

					if (backend.id === backendId && backend.value === value){
						console.log('contact ' + key);
						return this.contacts[key];
					}
				}
			}
		}
	};
}]);
angular.module('chat').factory('convs', ['contacts', '$filter', 'title', 'session', function(contacts, $filter, title, $session) {
	var convs = {};

	return {
		convs: convs, // DON NOT USE THIS! ONLY FOR ATTACHING TO THE SCOPE
		get : function(id) {
			return convs[id];
		},
		addConv : function(id, users, backend, msgs, files){
			//generate conv name + higher order of contacts
			var name  = '';
			for(var key in users){
				var user = users[key];
				if(user.id !== $session.user.id){
					name += user.displayname + ' ';
					var order = contacts.getHighestOrder();
					//$scope.contactsObj[user.id].order = order;
				}
			}
			// end generate conv name
			if(convs[id] === undefined) {
				//get highest order
				var order = this.getHighestOrder();
				convs[id] = {
					id : id,
					users : users,
					msgs : [],
					backend : backend,
					new_msg : false,
					raw_msgs : [],
					order : order,
					name : name,
					files : files
				};
				this.makeActive(id);
				if(msgs !== undefined){
					for (var key in msgs){
						var msg = msgs[key];
						this.addChatMsg(id, contacts[msg.user], msg.msg, msg.timestamp, backend);
					}
				}
			}
		},
		getHighestOrder : function(){
			var sortedConvs = $filter('orderObjectBy')(convs, 'order');
			if(sortedConvs[sortedConvs.length - 1] !== undefined){
				return sortedConvs[sortedConvs.length - 1].order + 1;
			} else {
				return 1;
			}
		},
		/**
		 * This will add an chat msg to an existing conversation
		 * This will call the notify() function when the message isn't send by the active user
		 * This will call the notifyMsgInConv() function when it isn't the active conv
		 * This will make the order of the conv the highest
		 * @param {string} convId
		 * @param {object} user
		 * @param {string} msg
		 * @param {int} timestamp
		 * @param {object} backend
		 * @param {bool} noNotify
		 */
		addChatMsg : function(convId, user, msg, timestamp, backend, noNotify){
			if(noNotify === undefined){
				noNotify = false;
			}
			if(user.id !== $session.user.id && noNotify === false){
				title.notify(user.displayname);
			}

			if(convId !== $session.conv && noNotify === false){
			//	this ins't the active conv
			//	we have to notify the user of new messages in this conv
				this.notifyMsgInConv(convId);
			}

			// Check if the user is equal to the user of the last msg
			// First get the last msg
			var contact = user;
			convs[convId].msgs.push({
				contact : contact,
				msg : $.trim(msg),
				timestamp : timestamp,
				time : Chat.app.util.timeStampToDate(timestamp),
			});

			// Add raw msgs to raw_msgs
			convs[convId].raw_msgs.push({"msg" : msg, "timestamp" : timestamp, "user" : user});
			convs[convId].order = this.getHighestOrder() +1;
		},
		/**
		 * This will replace the users in an existing conversation
		 * @param {string} convId
		 * @param {array} users - array with objects
		 */
		replaceUsers : function(convId, users){
			convs[convId].users = users;
		},
		/**
		 * This will bold the conversation name in the view
		 * @param {string} convId
		 */
		notifyMsgInConv : function(convId){
			convs[convId].new_msg = true;
		},
		/**
		* This will add an user to an conversation
		* @param {string} convId
		* @param {object} user
		*/
		addUserToConv : function(convId, user){
			if(convs[convId].users.indexOf(user) === -1){
				convs[convId].users.push(user);
			}
		},
		/**
		 * This function will return the first conversation in the conversation list
		 * @returns {object|undefined}
		 */
		getFirstConv : function(){
			for (var firstConv in convs) break;
			if (typeof firstConv !== 'undefined') {
				return firstConv;
			} else {
				return undefined;
			}
		},
		makeActive : function(convId, $event, exception) {
			$scope = $('#app').scope();
			if (!$scope.$$phase) {
				$scope.$apply(function () {
					$scope.view.makeActive(convId, $event, exception);
				});
			} else {
				$scope.view.makeActive(convId, $event, exception);
			}
		},
		attachFile : function(convId, path, timestamp, user){
			if(timestamp === undefined){
				timestamp = Time.now();
			}
			convs[convId].files.push({
				"path": path,
				"user": user,
				"timestamp" : timestamp
			});
			this.addChatMsg(convId, user,  tran('translations-attached', {displayname: user.displayname, path: path}),
				timestamp, 'och');
		},
		removeFile : function(convId, path, timestamp, user, key){
			convs[convId].files.splice(key, 1);
            this.addChatMsg(convId, user,  tran('translations-removed', {displayname: user.displayname, path: path}),
                timestamp, 'och');
		}
	};
}]);

angular.module('chat').factory('initvar', [function() {
	var initvar = JSON.parse($('#initvar').text());
	$('#initvar').text('');
	return initvar;
}]);
angular.module('chat').factory('title', [function() {
	var title;
	var default_title = 'Chat - ownCloud';
	var new_msgs = [];

	/**
	 * This will check if the window is active
	 *  if so
	 *   it will change the title of the page into 'New messages from {user}'
	 *  otherwise
	 *   it will empty the title
	 */
	return {
		/**
		 * This function will update the title of the page
		 * @param {string} newTitle
		 */
		updateTitle : function(newTitle){
			title = newTitle;
		},
		getDefaultTitle : function(){
			return default_title;
		},
		getTitle : function() {
			return title;
		},
		/**
		 * This function will add the user to the $scope.title.new_msgs array
		 * This way the user can be notified about a new msgs
		 * @param {string} user
		 */
		notify : function(user){
			if(new_msgs.indexOf(user) == -1){
				new_msgs.push(user);
			}
			var newTitle = 'New messages from ';
			if(new_msgs.length === 0 ){
				newTitle = '';
			} else {
				for (var key in new_msgs){
					var user = new_msgs[key];
					newTitle = newTitle + user + " ";
				}
			}
			this.updateTitle(newTitle);
		},
		emptyNewMsgs : function(){
			new_msgs = [];
			this.updateTitle('');
		}
	};
}]);
angular.module('chat').filter('count', function() {
    return function(items) {
        var count = 0;
        for (var key in items){
            count++;
        }
        return count;
    };
});
angular.module('chat').filter('enhanceFiles', [function() {
    return function(text) {
        var imgRegex = /(\S*\.(?:gif|jpg|jpeg|tiff|png|svg|webp))/gi;

        var img = '<a href="/index.php/apps/files/ajax/download.php?dir=/&files=$1">' + '<img alt="image" height="150px" src="/index.php/apps/files/ajax/download.php?dir=/&files=$1"/></a>';
        text = text.replace(imgRegex, img);
        return text;
    };
}]);

angular.module('chat').filter('filterUsersInConv', ['convs', 'session',function(convs, $session) {
	return function(contacts) {
		var result = [];
		var users = convs.get($session.conv).users;
		var usersId = [];
        for (var key in users){
            var user = users[key];
            usersId.push(user.id);
        }
        for (var key in contacts){
            var contact = contacts[key];
            if($.inArray(contact.id, usersId) === -1){
                result.push(contact);
            }
        }
		return result;
    };
}]);
angular.module('chat').filter('orderObjectBy', function() {
	return function(items, field, reverse) {
		var filtered = [];
		for (var key in items){
			var item = items[key];
			filtered.push(item);
		}
		filtered.sort(function (a, b) {
			return (a[field] > b[field] ? 1 : -1);
		});
		if(reverse) filtered.reverse();
		return filtered;
	};
});
angular.module('chat').filter('userFilter', function() {
	return function(users) {
		var output = [];
		for (var key in users){
			var user = users[key];
			if(user.id !== OC.currentUser){
				output.push(user);
			}
		}
		return output;
	};
})
angular.module('chat').value('session', {
	id: null,
	conv: null,
	user: {}
});

/**
 * Copyright (c) 2014, Tobia De Koninck hey--at--ledfan.be
 * This file is licensed under the AGPL version 3 or later.
 * See the COPYING file.
 */
(function ($) {
	$.fn.online = function(isonline) {
		var $div = this;
		if(isonline === 'true' || isonline === true){
			$div.next().addClass('online-dot');
		} else {
			$div.next().removeClass('online-dot');
		}
	};
}(jQuery));
